    ========================================================================================================
                            CHAP 1 - Introduction to Advanced Databases
========================================================================================================
Characteristics of DBMS

    It uses a digital repository established on a server to store and manage the information.
    It can provide a clear and logical view of the process that manipulates data.
    DBMS contains automatic backup and recovery procedures.
    It contains ACID properties which maintain data in a healthy state in case of failure.
    It can reduce the complex relationship between data.
    It is used to support manipulation and processing of data.
    It is used to provide security of data.
    It can view the database from different viewpoints according to the requirements of the user.

========================================================================================================
1.1 Database System Architectures

Types of DBMS Architecture

There are three types of DBMS architecture:

1. Single tier architecture
2. Two tier architecture
3. Three tier architecture

--------------------------------------------------------------------------------------------------------
1. Single tier architecture

In this type of architecture, the database is readily available on the client machine, any request made by client doesn’t require a network connection to perform the action on the database.

For example, lets say you want to fetch the records of employee from the database and the database is available on your computer system, so the request to fetch employee details will be done by your computer and the records will be fetched from the database by your computer as well. This type of system is generally referred as local database system.

--------------------------------------------------------------------------------------------------------
2. Two tier architecture

DBMS Architecture - 2-tier

https://beginnersbook.com/wp-content/uploads/2018/11/2-tier-architecture.png

In two-tier architecture, the Database system is present at the server machine and the DBMS application is present at the client machine, these two machines are connected with each other through a reliable network as shown in the above diagram.

Whenever client machine makes a request to access the database present at server using a query language like sql, the server perform the request on the database and returns the result back to the client. The application connection interface such as JDBC, ODBC are used for the interaction between server and client.

--------------------------------------------------------------------------------------------------------
3. Three tier architecture

DBMS Architecture - 3 tier

https://beginnersbook.com/wp-content/uploads/2018/11/3-tier-architecture.png

In three-tier architecture, another layer is present between the client machine and server machine. In this architecture, the client application doesn’t communicate directly with the database systems present at the server machine, rather the client application communicates with server application and the server application internally communicates with the database system present at the server.

========================================================================================================
1.2 Centtralized and Client-Server Architecture

Centralized Database :
A centralized database is basically a type of database that is stored, located as well as maintained at a single location only. This type of database is modified and managed from that location itself. This location is thus mainly any database system or a centralized computer system. The centralized location is accessed via an internet connection (LAN, WAN, etc). This centralized database is mainly used by institutions or organizations.

https://media.geeksforgeeks.org/wp-content/uploads/20200501155836/Capturedistributeddb.png

Advantages –

    1. This database can be easily expanded as data is already spread across different physical locations.
    2. The distributed database can easily be accessed from different networks.
    3. This database is more secure in comparison to centralized database.

Disadvantages –

    1. This database is very costly and it is difficult to maintain because of its complexity.
    2. In this database, it is difficult to provide a uniform view to user since it is spread across different physical locations.


--------------------------------------------------------------------------------------------------------
Client-server Database Architecture in DBMS

In client-server architecture many clients connected with one server. The server is centerlines.it provides services to all clients. All clients request to the server for different Service. The server displays the results according to the client’s request.

Client/server architecture is a computing model in which the server hosts (computer), send and manages most of the resources and works to be required by the client. In this type of architecture has one or more client computers attached to a central server over a network. This system shares different resources.

Client/server architecture is also called as a networking computing model and client-server network because all the requests and demands are sent over a network.

https://t4tutorials.com/wp-content/uploads/2019/09/Client-Server-Database-model.webp


Advantages of Client-server Database Architecture in DBMS

    All the data and resources are controlled by server .im this way all data and resources are very consistent.
    You can easily increase the number of client in this architecture at any time. This all increases the scalability of the network.
    This is very easy to maintain you can easily repair, replace or add clients in this network. the independence of the changes also known as encapsulation.
    This network is very easy to use and it is not complicated.

Disadvantages of Client-server Database Architecture in DBMS

    Traffic is a big problem in this network.
    When you add large numbers of the client with server this network will be more complicated.
    When the server goes down all the clients are not able to send their request. The whole work will be stopped
    The hardware and software are very expensive.
    The client does not have resources for each resource they need to request the server. Because of all resources exit on server

========================================================================================================
1.4 Parallel Systems

Introduction to Parallel Databases

Companies need to handle huge amount of data with high data transfer rate. The client server and centralized system is not much efficient. The need to improve the efficiency gave birth to the concept of Parallel Databases.

Parallel database system improves performance of data processing using multiple resources in parallel, like multiple CPU and disks are used parallely.

It also performs many parallelization operations like, data loading and query processing.

--------------------------------------------------------------------------------------------------------
Goals of Parallel Databases

 Improve performance:
 Improve availability of data:
 Improve reliability:
 Provide distributed access of data:

--------------------------------------------------------------------------------------------------------
Shared memory system

    Shared memory system uses multiple processors which is attached to a global shared memory via intercommunication channel or communication bus.
    Shared memory system have large amount of cache memory at each processors, so referencing of the shared memory is avoided.
    If a processor performs a write operation to memory location, the data should be updated or removed from that location.

https://www.tutorialride.com/images/parallel-databases/shared-memory-system.jpg

Advantages of Shared memory system

    Data is easily accessible to any processor.
    One processor can send message to other efficiently.

Disadvantages of Shared memory system

    Waiting time of processors is increased due to more number of processors.
    Bandwidth problem.

--------------------------------------------------------------------------------------------------------
Shared Disk System

    Shared disk system uses multiple processors which are accessible to multiple disks via intercommunication channel and every processor has local memory.
    Each processor has its own memory so the data sharing is efficient.
    The system built around this system are called as clusters.

https://www.tutorialride.com/images/parallel-databases/shared-disk-memory.jpg

Advantages of Shared Disk System

    Fault tolerance is achieved using shared disk system.
    Fault tolerance: If a processor or its memory fails, the other processor can complete the task. This is called as fault tolerance.

Disadvantage of Shared Disk System

    Shared disk system has limited scalability as large amount of data travels through the interconnection channel.
    If more processors are added the existing processors are slowed down.

Applications of Shared Disk System
    Digital Equipment Corporation(DEC): DEC cluster running relational databases use the shared disk system and now owned by Oracle.

--------------------------------------------------------------------------------------------------------
Shared nothing disk system

    Each processor in the shared nothing system has its own local memory and local disk.
    Processors can communicate with each other through intercommunication channel.
    Any processor can act as a server to serve the data which is stored on local disk.

https://www.tutorialride.com/images/parallel-databases/shared-nothing-disk-system.jpg

Advantages of Shared nothing disk system

    Number of processors and disk can be connected as per the requirement in share nothing disk system.
    Shared nothing disk system can support for many processor, which makes the system more scalable.

Disadvantages of Shared nothing disk system

    Data partitioning is required in shared nothing disk system.
    Cost of communication for accessing local disk is much higher.

Applications of Shared nothing disk system

    Tera data database machine.
    The Grace and Gamma research prototypes.

--------------------------------------------------------------------------------------------------------
Hierarchical System or Non-Uniform Memory Architecture

    Hierarchical model system is a hybrid of shared memory system, shared disk system and shared nothing system.
    Hierarchical model is also known as Non-Uniform Memory Architecture (NUMA).
    In this system each group of processor has a local memory. But processors from other groups can access memory which is associated with the other group in coherent.
    NUMA uses local and remote memory(Memory from other group), hence it will take longer time to communicate with each other.

Advantages of NUMA

    Improves the scalability of the system.
    Memory bottleneck(shortage of memory) problem is minimized in this architecture.

Disadvantages of NUMA
The cost of the architecture is higher compared to other architectures.

========================================================================================================
1.5 Distributed Database System

A distributed database is basically a database that is not limited to one system, it is spread over different sites, i.e, on multiple computers or over a network of computers. A distributed database system is located on various sited that don’t share physical components. This maybe required when a particular database needs to be accessed by various users globally. It needs to be managed such that for the users it looks like one single database. 

 Types:
1. Homogeneous Database:

In a homogeneous database, all different sites store database identically. The operating system, database management system and the data structures used – all are same at all sites. Hence, they’re easy to manage.

2. Heterogeneous Database:

In a heterogeneous distributed database, different sites can use different schema and software that can lead to problems in query processing and transactions. Also, a particular site might be completely unaware of the other sites. Different computers may use a different operating system, different database application. They may even use different data models for the database. Hence, translations are required for different sites to communicate. 

--------------------------------------------------------------------------------------------------------
Distributed Data Storage

There are 2 ways in which data can be stored on different sites. These are:
1. Replication
In this approach, the entire relation is stored redundantly at 2 or more sites. If the entire database is available at all sites, it is a fully redundant database. Hence, in replication, systems maintain copies of data.
This is advantageous as it increases the availability of data at different sites. Also, now query requests can be processed in parallel.
However, it has certain disadvantages as well. Data needs to be constantly updated. Any change made at one site needs to be recorded at every site that relation is stored or else it may lead to inconsistency. This is a lot of overhead. Also, concurrency control becomes way more complex as concurrent access now needs to be checked over a number of sites.

2. Fragmentation
In this approach, the relations are fragmented (i.e., they’re divided into smaller parts) and each of the fragments is stored in different sites where they’re required. It must be made sure that the fragments are such that they can be used to reconstruct the original relation (i.e, there isn’t any loss of data).
Fragmentation is advantageous as it doesn’t create copies of data, consistency is not a problem.
Fragmentation of relations can be done in two ways:

    1. Horizontal fragmentation – Splitting by rows – The relation is fragmented into groups of tuples so that each tuple is assigned to at least one fragment.
    2. Vertical fragmentation – Splitting by columns – The schema of the relation is divided into smaller schemas. Each fragment must contain a common candidate key so as to ensure lossless join.

In certain cases, an approach that is hybrid of fragmentation and replication is used. 

========================================================================================================
                                    CHAP 2 - Parallel Databases
========================================================================================================
2.1 Introduction

refer 1.4

========================================================================================================
2.2 Goals of Parallel Databases

refer 1.4

========================================================================================================
2.3 Different types of Database Parallelism

Parallelism is used to support speedup, where queries are executed faster because more resources, such as processors and disks, are provided. Parallelism is also used to provide scale-up, where increasing workloads are managed without increase response-time, via an increase in the degree of parallelism.

Different architectures for parallel database systems are shared-memory, shared-disk, shared-nothing, and hierarchical structures.

--------------------------------------------------------------------------------------------------------
a)Horizontal Parallelism: It means that the database is partitioned across multiple disks, and parallel processing occurs within a specific task (i.e., table scan) that is performed concurrently on different processors against different sets of data.

(b)Vertical Parallelism: It occurs among various tasks. All component query operations (i.e., scan, join, and sort) are executed in parallel in a pipelined fashion. In other words, an output from one function (e.g., join) as soon as records become available.

https://static.javatpoint.com/tutorial/datawarehouse/images/data-warehouse-types-of-database-parallelism.png

--------------------------------------------------------------------------------------------------------
Intraquery Parallelism

Intraquery parallelism defines the execution of a single query in parallel on multiple processors and disks. Using intraquery parallelism is essential for speeding up long-running queries.

Interquery parallelism does not help in this function since each query is run sequentially.

To improve the situation, many DBMS vendors developed versions of their products that utilized intraquery parallelism.

This application of parallelism decomposes the serial SQL, query into lower-level operations such as scan, join, sort, and aggregation.

These lower-level operations are executed concurrently, in parallel.

--------------------------------------------------------------------------------------------------------
Interquery Parallelism

In interquery parallelism, different queries or transaction execute in parallel with one another.

This form of parallelism can increase transactions throughput. The response times of individual transactions are not faster than they would be if the transactions were run in isolation.

Thus, the primary use of interquery parallelism is to scale up a transaction processing system to support a more significant number of transactions per second.

Database vendors started to take advantage of parallel hardware architectures by implementing multiserver and multithreaded systems designed to handle a large number of client requests efficiently.

This approach naturally resulted in interquery parallelism, in which different server threads (or processes) handle multiple requests at the same time.

Interquery parallelism has been successfully implemented on SMP systems, where it increased the throughput and allowed the support of more concurrent users.

--------------------------------------------------------------------------------------------------------
Shared memory system
Shared disk system
Shared nothing system
Hierarchical

refer 1.4

========================================================================================================
2.4 Performance Parameters

Some parameters to judge the performance of Parallel Databases are:

--------------------------------------------------------------------------------------------------------
1. Response time: It is the time taken to complete a single task for given time.

--------------------------------------------------------------------------------------------------------
2. Speed up in Parallel database:

    * Speed up is the process of  increasing degree of (resources) parallelism to complete a running task in less time.
    * The time required for running task is inversely proportional to number of resources.

Formula:
Speed up = TS / TL
Where,
     TS = Time required to execute task of size Q
     TL = Time required to execute task of size N*Q

https://www.tutorialride.com/images/parallel-databases/scale-up-databases.jpg

speed up databases
Linear speed-up is N (Number of resources).
Speed-up is sub-linear if speed-up is less than N.

--------------------------------------------------------------------------------------------------------
3. Scale up in Parallel database:
Scale-up is the ability to keep performance constant, when number of process and resources increases proportionally.

Formula:
Let Q be the Task and QN the task where N is greater than Q
TS = Execution time of task Q on smaller machine MS
TL = Execution time of task Q on smaller machine ML

Scale Up = TS /TL

========================================================================================================
2.5 Parallel Data Architecture

Shared memory system
Shared disk system
Shared nothing system
Hierarchical

refer 1.4

========================================================================================================
2.6 Evaluation of Parallel Query

________________________________________________________________________________________________________
2.6.1 Inter and Intra Query Parallelism

1. Inter query parallelism

    This technique allows to run multiple queries on different processors simultaneously.
    Pipelined parallelism is achieved by using inter query parallelism, which improves the output of the system.

    For example: If there are 6 queries, each query will take 3 seconds for evaluation. Thus, the total time taken to complete evaluation process is 18 seconds. Inter query parallelism achieves this task only in 3 seconds.
    However, Inter query parallelism is difficult to achieve every time.

2. Intra Query Parallelism

    In this technique query is divided in sub queries which can run simultaneously on different processors, this will minimize the query evaluation time.
    Intra query parallelism improves the response time of the system.

    For Example: If we have 6 queries, which can take 3 seconds to complete the evaluation process, the  total time to complete the evaluation process is 18 seconds. But We can achieve this task in only 3 seconds by using intra query evaluation as each query is divided in sub-queries.

========================================================================================================
2.7 Optimization of Parallel Query

    * Parallel Query optimization is nothing but selecting the efficient query evaluation plan.
    * Parallel Query optimization plays an important role in developing system to minimize the cost of query evaluation.

Two factors play a very important in parallel query optimization.

a) total time spent to find the best plan.
b) amount of time required to execute the plan.


Goals of Query optimization.

Query Optimization is done with an aim to:

    * Speed up the queries by finding the queries which can give the fastest result on execution.
    * Increase the performance of the system.
    * Select the best query evaluation plan.
    * Avoid the unwanted plan.

========================================================================================================
2.8 Virtualization

    * The processing power of the computer is increased by adding many CPUs. This technique is referred as virtualization.
    * Multiple CPUs are added to the host machine which can improve the performance of the system.
    * There are no specific rules for adding number of CPUs.
    * Multicore processors have the ability to solve the complicated processing.
    * This technique is used for heavy load process.

https://www.tutorialride.com/images/parallel-databases/virtualization.jpg


========================================================================================================
                                    CHAP 3 - Distributed Databases
========================================================================================================
3.1 Introduction

A distributed database is basically a database that is not limited to one system, it is spread over different sites, i.e, on multiple computers or over a network of computers. A distributed database system is located on various sited that don’t share physical components. This maybe required when a particular database needs to be accessed by various users globally. It needs to be managed such that for the users it looks like one single database.

* Distributed database is a system in which storage devices are not connected to a common processing unit.
* Database is controlled by Distributed Database Management System and data may be stored at the same location or spread over the
  interconnected network. It is a loosely coupled system.
* Shared nothing architecture is used in distributed databases.

https://www.tutorialride.com/images/distributed-databases/distributed-system.jpeg

========================================================================================================
3.2 Goals of Distributed Databases

Goals of Distributed Database system.
The concept of distributed database was built with a goal to improve:

Reliability: In distributed database system, if one system fails down or stops working for some time another system can complete the task.
Availability: In distributed database system reliability can be achieved even if sever fails down. Another system is available to serve the client request.
Performance: Performance can be achieved by distributing database over different locations. So the databases are available to every location which is easy to maintain.

========================================================================================================
3.3 Types of Distributed databases

Fragmentation

Fragmentation is the task of dividing a table into a set of smaller tables. The subsets of the table are called fragments. Fragmentation can be of three types: horizontal, vertical, and hybrid (combination of horizontal and vertical). Horizontal fragmentation can further be classified into two techniques: primary horizontal fragmentation and derived horizontal fragmentation.

Fragmentation should be done in a way so that the original table can be reconstructed from the fragments. This is needed so that the original table can be reconstructed from the fragments whenever required. This requirement is called “reconstructiveness.”

--------------------------------------------------------------------------------------------------------
Vertical Fragmentation

In vertical fragmentation, the fields or columns of a table are grouped into fragments. In order to maintain reconstructiveness, each fragment should contain the primary key field(s) of the table. Vertical fragmentation can be used to enforce privacy of data.

For example, let us consider that a University database keeps records of all registered students in a Student table having the following schema.

STUDENT
Regd_No 	Name 	Course 	Address 	Semester 	Fees 	Marks

Now, the fees details are maintained in the accounts section. In this case, the designer will fragment the database as follows −

CREATE TABLE STD_FEES AS 
   SELECT Regd_No, Fees 
   FROM STUDENT;

--------------------------------------------------------------------------------------------------------
Horizontal Fragmentation

Horizontal fragmentation groups the tuples of a table in accordance to values of one or more fields. Horizontal fragmentation should also confirm to the rule of reconstructiveness. Each horizontal fragment must have all columns of the original base table.

For example, in the student schema, if the details of all students of Computer Science Course needs to be maintained at the School of Computer Science, then the designer will horizontally fragment the database as follows −

CREATE COMP_STD AS 
   SELECT * FROM STUDENT  
   WHERE COURSE = "Computer Science";

--------------------------------------------------------------------------------------------------------
Hybrid Fragmentation

In hybrid fragmentation, a combination of horizontal and vertical fragmentation techniques are used. This is the most flexible fragmentation technique since it generates fragments with minimal extraneous information. However, reconstruction of the original table is often an expensive task.

Hybrid fragmentation can be done in two alternative ways −

    At first, generate a set of horizontal fragments; then generate vertical fragments from one or more of the horizontal fragments.

    At first, generate a set of vertical fragments; then generate horizontal fragments from one or more of the vertical fragments.

========================================================================================================
3.4 Data Replication

Data replication is the process of storing separate copies of the database at two or more sites. It is a popular fault tolerance technique of distributed databases.

Advantages of Data Replication

    Reliability − In case of failure of any site, the database system continues to work since a copy is available at another site(s).

    Reduction in Network Load − Since local copies of data are available, query processing can be done with reduced network usage, particularly during prime hours. Data updating can be done at non-prime hours.

    Quicker Response − Availability of local copies of data ensures quick query processing and consequently quick response time.

    Simpler Transactions − Transactions require less number of joins of tables located at different sites and minimal coordination across the network. Thus, they become simpler in nature.

Disadvantages of Data Replication

    Increased Storage Requirements − Maintaining multiple copies of data is associated with increased storage costs. The storage space required is in multiples of the storage required for a centralized system.

    Increased Cost and Complexity of Data Updating − Each time a data item is updated, the update needs to be reflected in all the copies of the data at the different sites. This requires complex synchronization techniques and protocols.

    Undesirable Application – Database coupling − If complex update mechanisms are not used, removing data inconsistency requires complex co-ordination at application level. This results in undesirable application – database coupling.

========================================================================================================
3.6 Query Processing and Optimization

Distributed Query Processing Architecture

In a distributed database system, processing a query comprises of optimization at both the global and the local level. The query enters the database system at the client or controlling site. Here, the user is validated, the query is checked, translated, and optimized at a global level.

https://www.tutorialspoint.com/distributed_dbms/images/distributed_query_architecture.jpg

Mapping Global Queries into Local Queries

The process of mapping global queries to local ones can be realized as follows −

    The tables required in a global query have fragments distributed across multiple sites. The local databases have information only about local data. The controlling site uses the global data dictionary to gather information about the distribution and reconstructs the global view from the fragments.

    If there is no replication, the global optimizer runs local queries at the sites where the fragments are stored. If there is replication, the global optimizer selects the site based upon communication cost, workload, and server speed.

    The global optimizer generates a distributed execution plan so that least amount of data transfer occurs across the sites. The plan states the location of the fragments, order in which query steps needs to be executed and the processes involved in transferring intermediate results.

    The local queries are optimized by the local database servers. Finally, the local query results are merged together through union operation in case of horizontal fragments and join operation for vertical fragments.

--------------------------------------------------------------------------------------------------------
Distributed Query Optimization

Distributed query optimization requires evaluation of a large number of query trees each of which produce the required results of a query. This is primarily due to the presence of large amount of replicated and fragmented data. Hence, the target is to find an optimal solution instead of the best solution.

The main issues for distributed query optimization are −

    * Optimal utilization of resources in the distributed system.
    * Query trading.
    * Reduction of solution space of the query.

________________________________________________________________________________________________________
Optimal Utilization of Resources in the Distributed System

A distributed system has a number of database servers in the various sites to perform the operations pertaining to a query. Following are the approaches for optimal resource utilization −

Operation Shipping − In operation shipping, the operation is run at the site where the data is stored and not at the client site. The results are then transferred to the client site. This is appropriate for operations where the operands are available at the same site. Example: Select and Project operations.

Data Shipping − In data shipping, the data fragments are transferred to the database server, where the operations are executed. This is used in operations where the operands are distributed at different sites. This is also appropriate in systems where the communication costs are low, and local processors are much slower than the client server.

Hybrid Shipping − This is a combination of data and operation shipping. Here, data fragments are transferred to the high-speed processors, where the operation runs. The results are then sent to the client site.

https://www.tutorialspoint.com/distributed_dbms/images/optimal_utilization_distributed_system.jpg

________________________________________________________________________________________________________
Query Trading

In query trading algorithm for distributed database systems, the controlling/client site for a distributed query is called the buyer and the sites where the local queries execute are called sellers. The buyer formulates a number of alternatives for choosing sellers and for reconstructing the global results. The target of the buyer is to achieve the optimal cost.

The algorithm starts with the buyer assigning sub-queries to the seller sites. The optimal plan is created from local optimized query plans proposed by the sellers combined with the communication cost for reconstructing the final result. Once the global optimal plan is formulated, the query is executed.

________________________________________________________________________________________________________
Reduction of Solution Space of the Query

Optimal solution generally involves reduction of solution space so that the cost of query and data transfer is reduced. This can be achieved through a set of heuristic rules, just as heuristics in centralized systems.

Following are some of the rules −

    Perform selection and projection operations as early as possible. This reduces the data flow over communication network.

    Simplify operations on horizontal fragments by eliminating selection conditions which are not relevant to a particular site.

    In case of join and union operations comprising of fragments located in multiple sites, transfer fragmented data to the site where most of the data is present and perform operation there.

    Use semi-join operation to qualify tuples that are to be joined. This reduces the amount of data transfer which in turn reduces communication cost.

    Merge the common leaves and sub-trees in a distributed query tree.

========================================================================================================
3.7 Recovery 

Recovery is the most complicated process in distributed databases. Recovery of a failed system in the communication network is very difficult.

--------------------------------------------------------------------------------------------------------
3.7.1 Two-phase commit protocol

* Two-phase protocol is a type of atomic commitment protocol. This is a distributed algorithm which can coordinate all the processes that participate in the database and decide to commit or terminate the transactions. The protocol is based on commit and terminate action.

* The two-phase protocol ensures that all participant which are accessing the database server can receive and implement the same action (Commit or terminate), in case of local network failure.

* Two-phase commit protocol provides automatic recovery mechanism in case of a system failure.

* The location at which original transaction takes place is called as coordinator and where the sub process takes place is called as Cohort.

Commit request:
In commit phase the coordinator attempts to prepare all cohorts and take necessary steps to commit or terminate the transactions.

Commit phase:
The commit phase is based on voting of cohorts and the coordinator decides to commit or terminate the transaction.

--------------------------------------------------------------------------------------------------------
3.7.2 Concurrency problems

Some problems which occur while accessing the database are as follows:

1. Failure at local locations
When system recovers from failure the database is out dated compared to other locations. So it is necessary to update the database.

2. Failure at communication location
System should have a ability to manage temporary failure in a communicating network in distributed databases. In this case, partition occurs which can limit the communication between two locations.

3. Dealing with multiple copies of data
It is very important to maintain multiple copies of distributed data at different locations.

4. Distributed commit
While committing a transaction which is accessing databases stored on multiple locations, if failure occurs on some location during the commit process then this problem is called as distributed commit.

5. Distributed deadlock
Deadlock can occur at several locations due to recovery problem and concurrency problem (multiple locations are accessing same system in the communication network).

--------------------------------------------------------------------------------------------------------
3.7.3 Concurrency Controls

There are three different ways of making distinguish copy of data by applying:

1) Lock based protocol
A lock is applied to avoid concurrency problem between two transaction in such a way that the lock is applied on one transaction and other transaction can access it only when the lock is released. The lock is applied on write or read operations. It is an important method to avoid deadlock.

2) Shared lock system (Read lock)
The transaction can activate shared lock on data to read its content. The lock is shared in such a way that any other transaction can activate the shared lock on the same data for reading purpose.

3) Exclusive lock
The transaction can activate exclusive lock on a data to read and write operation. In this system, no other transaction can activate any kind of lock on that same data.

========================================================================================================
                                    CHAP 4 - Object Based Databases
========================================================================================================
4.1 Concepts of Object Database

    * Object oriented database systems are alternative to relational database and other database systems.

    * In object oriented database, information is represented in the form of objects.

    * Object oriented databases are exactly same as object oriented programming languages. If we can combine the features of relational model (transaction, concurrency, recovery) to object oriented databases, the resultant model is called as object oriented database model.

https://www.tutorialride.com/images/distributed-databases/object-oriented-database.jpg

========================================================================================================
4.2 Features of OODBMS

In OODBMS, every entity is considered as object and represented in a table. Similar objects are classified to classes and subclasses and relationship between two object is maintained using concept of inverse reference.

Some of the features of OODBMS are as follows:

1. Complexity
OODBMS has the ability to represent the complex internal structure (of object) with multilevel complexity.

2. Inheritance
Creating a new object from an existing object in such a way that new object inherits all characteristics of an existing object.

3. Encapsulation
It is an data hiding concept in OOPL which binds the data and functions together which can manipulate data and not visible to outside world.

4. Persistency
OODBMS allows to create persistent object (Object remains in memory even after execution). This feature can automatically solve the problem of recovery and concurrency.

========================================================================================================
4.3 Challenges in ORDBMS implementation

During the implementation of ORDBMS, various challenges arise which need to be resolved. They are:

1. Storage and accessibility of data
It is possible to define new types with new access to structures with the help of OODBMS. Hence, it is important that the system must store ADT and structured objects efficiently along with the provision of indexed access.
Challenge : Storage of large ADTs and structured objects.
Solution: As large ADTs need special storage, it is possible to store them on different locations on the disk from the tuples that contain them. For e.g. BLOBs (Binary Large Object like images, audio or any multimedia object.)
Use of flexible disk layout mechanisms can solve the storage problem of structured objects.

2. Query Processing

Challenge: Efficient flow of Query Processing and optimization is a difficult task.
Solution: By registering the user defined aggregation function, query processing becomes easier. It requires three implementation steps - initialize, iterate and terminate.

3. Query Optimization

Challenge: New indexes and query processing techniques increase the options for query optimization. But, the challenge is that the optimizer must know to handle and use the query processing functionality properly.
Solution: While constructing a query plan, an optimizer must be familiar to the newly added index structures.

For a given index structure, the optimizer must know:

1. WHERE-clause conditions matched by that index.
2. Cost of fetching a tuple for that index. 

========================================================================================================
4.4 Object Identity - Object structure

The ODBMS which is an abbreviation for object oriented database management system, is the data model in which data is stored in form of objects, which are instances of classes.
 These classes and objects together makes an object oriented data model.

 Components of Object Oriented Data Model: 
The OODBMS is based on three major components, namely: Object structure, Object classes, and Object identity. 
These are explained as following below. 

1. Object Structure: 
The structure of an object refers to the properties that an object is made up of. 
These properties of an object are referred to as an attribute. 
Thus, an object is a real world entity with certain attributes that makes up the object structure. 
Also an object encapsulates the data code into a single unit which in turn provides data abstraction by hiding the implementation details from the user. 

2. Object identity:
Every object has unique identity. In an object oriented system, when object is created OID is assigned to it.
In RDBMS OID is value based and primary key is used to provide uniqueness of each table in relation. 
Primary key is unique only for that relation and not for the entire system. 
Primary key is chosen from the attributes of the relation which makes object independent on the object state.
In OODBMS OID are variable name or pointer.

========================================================================================================
4.5 Objects and Attributes

What is Object?
 Object consists of entity and attributes which can describe the state of real world object and action associated with that object.

Attributes
 Attributes are nothing but the properties of objects in the system.

Type of Attributes
 The three types of attributes are : 1.simple 2.complex 3.reference

--------------------------------------------------------------------------------------------------------
Type Constructors

Object Definition Language (ODL) that includes type constructors can be used to define object types for particular DB application.
Type constructors in ODL are used to define data structures for OO database schema.
In OO databases, the state (current value) of a complex object may be constructed from other objects (or other values) by usingcertain type constructors.
The three most basic constructors are atom, tuple and set. Other commonly used constructors include list, bag, and array. 
The atom constructor is used to represent all basic atomic values, such as integers, real numbers, character strings, Booleans,and 
any other basic data types that the system supports directly

--------------------------------------------------------------------------------------------------------
Encapsulation of Operations

Encapsulation is related to the concepts of abstract data types and information hiding in programming languages. Here the main idea is to define the behavior of a type of object based on the operations that can be externally applied to objects of that type. The internal structure of the object is hidden, and the object is only accessible through a number of predefined operations. Some operations may be used to create or destroy objects; other operations may update the object value and other may be used to retrieve parts of the object value or to apply some calculations to the object value. 

--------------------------------------------------------------------------------------------------------
Methods

Methods are procedures, internal to each object, which alter an objectâ€™s private state. State here means the values of the data items of the object in question.

Examples of methods

Some examples of commonly found methods are as follows:

Constructors: These are used whenever a new instance of an object is created. They initialise the data items contained within the object instance. It is possible for objects to have a number of different constructors, if it is required that they should sometimes be created with different starting values for their data items.

Destructors: These methods are used when an instance of an object is deleted. They ensure that any resources that are held by the object instance, such as storage space, are released.

Transformers: These methods are used to change an object's internal state. There may be a number of transformer methods used to bring about changes to the data items of an object instance.

The Object-oriented approach, therefore, provides the ability to deal with objects and operations on those objects, that are more closely related to the real world. This has the effect of raising the level of abstraction from that used in Relational constructs, such as tables, theoretically making the data model easier to understand and use.

--------------------------------------------------------------------------------------------------------
Persistence

Not all objects are meant to be stored permanently in the database. Transient objects exist in the executing program and disappear once the program terminates.

Persistent objects are stored in the database and persist after program terminates. The typical mechanism for persistence involves giving an object a unique persistent name through which it can be retrieved.

--------------------------------------------------------------------------------------------------------
Type and Class Hierarchy

A class hierarchy provides an inheritance mechanism which allows a class to inherit properties (attributes and methods) from its superclasses.
In single inheritance systems, a class can have at most one direct superclass and therefore can only inherit from that superclass.
The class hierarchy forms a tree.
In multiple inheritance systems, a class can have more than one direct superclass.
The class hierarchy is a lattice.

========================================================================================================
4.6  Structured and Unstructured Data

Structured data is the data which is organized in such a way that relational database can easily search. Unstructured data is not properly organized and this increases the compilation time of a program.

--------------------------------------------------------------------------------------------------------
Operations on structured and unstructured data
Some functions, which are very important to create and manipulate an object are:

1. Type constructor

    Type constructor is used to create UDT (user defined data types),which is needed if data-type is complex.
    A row type is a sequence of field name or data type.

Syntax
CREATE TYPE Row_Type_Name AS [ROW]
(<component declarations>)
Where the keyword ROW is optional 

--------------------------------------------------------------------------------------------------------
2. Object identifier by using References
A row type can be used as type (Data type) for attribute. It can be used to create tables.
Some functions to create an object identifier are as given below:

1) Create a system generated object identifier

2) Reference attribute
Component tuple of one relation can be referenced to tuple of another table.

3) Dot notation
A dot (.) notation is used for building path which refers to the component attribute of various row types.

--------------------------------------------------------------------------------------------------------

3. Data encapsulation and ADT
User can create own user-defined type with its behavioral and specification by specifying operations to attributes.

Syntax
CREATE TYPE <type-name>
(
Component attributes and their types
EQUAL and LESS THAN functions
);


========================================================================================================
                                        CHAP 5 - XML Databases
========================================================================================================
5.1 XML Data Model

    * XML stands for Extensible Markup language.
    * It was developed by W3C ( World Wide Web Consortium).
    * XML is a self-descriptive language.
    * XML is used to store and carry data.

Applications of XML

Mobiles: XML is used to display the text, images and sounds in the mobile softwares.
Converters: Converters are used to convert existing documents into XML format.
Example: PDF to XML.
Voice XML: Converts the XML documents into an audio format.

Features of XML

XML provides domain specific self describing tags.
It carries data with HTML.
XML allows interchanging of data between different computer application.
User defined tags in XML allow to search.

========================================================================================================
5.2 DTD

    DTD stands for Document Type Definition.
    It is used to validate the XML documents.
    XML provides facility to create your own DTDs for XML document.
    DTD specifies the structure of the XML document.
    DTD is part of the file or separate document file.

--------------------------------------------------------------------------------------------------------
Types of DTD

There are two types of DTDs:
    a) Internal DTD.
    b) External DTD.

Internal DTD   
Internal DTD is part of the document.
The scope is limited to the document which is created.
Syntax:
<!DOCTYPE rootelement[element and attribute declarations]>	

 <?xml version="1.0"?>
<!DOCTYPE note [
<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
]>
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend</body>
</note> 
________________________________________________________________________________________________________
External DTD
External DTD is a separate file.
It is accessible across the multiple documents.
Syntax:
<!DOCTYPE rootelement|SYSTEM “path of .dtd file”>

 <?xml version="1.0"?>
<!DOCTYPE note SYSTEM "note.dtd">
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note> 

And here is the file "note.dtd", which contains the DTD:
<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)> 

--------------------------------------------------------------------------------------------------------

Components of DTD
We have to associate the .xml file with the DTD and run the same .xml file in the browser.

Syntax for declaring elements in DTD:
<!ELEMENT elementname (content-type or content-model)>

Where elementname specifies the name of the element present in the xml document and content-type or content-model specifies whether the element contains textual data or other elements.

The three types of elements are as follows:

Element type	Description	                                                        DTD Declaration
Empty	        Contains attributes, but can't contain text or any other element.	<!Element elementname EMPTY>
Unrestricted	Contains text content or any other element.	                        <!ELEMENT elementname ANY>
Container	    Contain another elements.                        <!ELEMENT elementname (elementname, elementname [elementname])>

--------------------------------------------------------------------------------------------------------
Declaring Attributes in DTD

Each attribute declaration must include at least the attribute name in a DTD as follows:

Value Type	    Description
----------------------------------------------------------------------------------
PCDATA	        Represents the plain text values.
ID	            Assigns unique value to each element in the document.
(enumerated)	Assigns a specific range of values which is specified within parenthesis.

<!ATTLIST element-name attribute-name attribute-type attribute-value>

DTD example:

<!ATTLIST payment type CDATA "check">

XML example:

<payment type="check" /> 

========================================================================================================
5.3 XML Schema

What is XML schema?

    XML schema defines the structure of an XML document.
    A schema defines, list of elements, attributes used in XML documents and data type of these elements.
    It is known as XSD.

XSD vs DTD

XSD

* Defines list, order, data types of elements and attributes.
* Provides control over the elements and attributes used in XML documents.
* XSD allows to create customized datatype.
* Syntax of XSD is similar to XML document.
* XSD allows to define restrictions on data.
  For example: Define the content in a  document by using only integer data type.

DTD

* Defines list, order of elements and attributes.
* It does not provide control over elements and attributes.
* DTD does not allow to create customized datatype.
* Syntax of DTD is different from XML document.
* DTD does not allows to define restrictions on data.

--------------------------------------------------------------------------------------------------------
Declaring Elements in XSD
Syntax:
<xsd:element name =“elementname” type=“datatype” minOccurs = “notNegativeInteger” maxOccurs=“nonNegativeInteger | unbounded”/>

Where,
     name: Defines the element name

     type: Defines data type.

     minOccurs: If its value is zero, the use of element is optional and if its value is greater than zero, the use of element is compulsory, and should occur at least for specified number of times.

     maxOccurs: If value is set as unbounded, the use of element can appear any number of times in the XML document without any limitation.

========================================================================================================
5.4 XML Query


What is XQuery?

XQuery is to XML what SQL is to databases.

XQuery is designed to query XML data.


XQuery Example

for $x in doc("books.xml")/bookstore/book
where $x/price>30
order by $x/title
return $x/title


    * XQuery is the language for querying XML data
    * XQuery for XML is like SQL for databases
    * XQuery is built on XPath expressions
    * XQuery is supported by all major databases
    * XQuery is a W3C Recommendation

--------------------------------------------------------------------------------------------------------
XQuery can be used to:

    Extract information to use in a Web Service
    Generate summary reports
    Transform XML data to XHTML
    Search Web documents for relevant information

--------------------------------------------------------------------------------------------------------
XML Query:
XML query is based on two methods.

1. Xpath:

    Xpath is a syntax for defining parts or elements of XML documents.
    Xpath is used to navigate between elements and attributes in the XML documents.
    Xpath uses path of expressions to select nodes in XML documents.

Example:
In this example, the tree structure of employee is represented in the form of XML document.

<Employee>
     <Name>
          <First name>Brian</First name>
          <Last name>Lara<</Last name>
     </Name>
     <Contact>
          <Mobile>9800000000</Mobile>
          <Landline>020222222</Landline>
     </Contact>
     <Address>
          <City>Pune</city>
          <Street>Tilak road</Street>
          <Zip code>4110</Zip code>
     </Address>
</Employee>


2. Xquery:

    Xquery is a query and functional programming language. Xquery provides a facility to extract and manipulate data from XML documents or any data source, like relational database.
    The Xquery defines FLWR expression which supports iteration and binding of variable to intermediate results.
    FLWR is an abbreviation of FOR, LET, WHERE, RETURN. Which are explained as follows:
    FOR: Creates a sequence of nodes.
    LET: Binds a sequence to variable.
    WHERE: Filters the nodes on condition.
    RETURN: It is query result specification.

Lets take an example to understand how to write a XMLquery.

FOR $x in doc (“student.xml”)/student information /marks
WHERE $x/marks >700
RETURN <res>
                    $x/Name
               </res>

========================================================================================================
5.5 XML Database Types

There are two major types of XML databases −

    XML- enabled
    Native XML (NXD)

XML - Enabled Database

XML enabled database is nothing but the extension provided for the conversion of XML document. This is a relational database, where data is stored in tables consisting of rows and columns. The tables contain set of records, which in turn consist of fields.
Native XML Database

Native XML

Native XML database is based on the container rather than table format. It can store large amount of XML document and data. Native XML database is queried by the XPath-expressions.

Native XML database has an advantage over the XML-enabled database. It is highly capable to store, query and maintain the XML document than XML-enabled database.

========================================================================================================
5.6 JDBC


========================================================================================================
5.7 Information Retrieval

Information retrieval (IR) systems are often contrasted with relational databases. Traditionally, IR systems have retrieved information from unstructured text – by which we mean “raw” text without markup. Databases are designed for querying relational data, sets of records that have values for predefined attributes such as employee number, title, and salary.


========================================================================================================
                                        CHAP 6 - Big Databases
========================================================================================================
6.1 Introduction

With an ever increasing growth of databases in activities like social networking, online shopping, e-learning, e-banking etc;managing such a huge amount of data is  very big challenge.
The traditional data management systems and other existing tools are facing difficulties to analyze and process such a bigdata.
'Big Data' means a collection of the structured and unstructured data which is large and difficult to analyze and processwith traditional data management system.

========================================================================================================
6.2 Four V’s of Big data

Big data provides some important parameters for data processing. They are:

1. Volume:
It refers to the generation of large amount of data during data processing by using an application at every moment.
For example: Twitter Messages

2. Velocity:
It refers to the speed at which new data is generated and the speed at which data moves around the globe.
For example: Stock Exchange.

3. Variety:
It refers to the different types of data which are used in processing. The data can be structured or unstructured.
For example: In face-book, user can share data in the form of text, audio, video.

4. Veracity:
It refers to the trustworthiness of the data, Reliability data is important for organizations as well as users.
For example:  Twitter post with abbreviations.


========================================================================================================
6.3 NoSQL Databases

Introduction

    NoSQL can be referred to as non relational databases.
    NoSQL provides the process of storage and retrieval of data which is different than the relational databases. For example: NoSQL can store the data in the form of document.
    NoSQL consists of data like user information, social graphs, geographic location data and other user-generated content.

========================================================================================================
6.4 Examples of NoSQL DB

Examples of NoSQL databases: MongoDB, Cassandra.

========================================================================================================
6.5 Advantages

Advantages of NoSQL

    NoSQL supports non relational databases and is also called as not only SQL.
    NoSQL has a dynamic schema in which new data is added automatically.
    It is highly scalable.
    NoSQL provides the support for distributed computing.

--------------------------------------------------------------------------------------------------------
Disadvantages of NosQL

    NoSQL does not have the defined standard.
    NoSQL has a limited capability of queries.

========================================================================================================
6.7 NoSQL Vs SQL

SQL

SQL stores data in the table.
SQL provides standard platform to run complex queries.
Supports the structured and organized data.
SQL works on ACID properties.	NoSQL follows CAP theorem.
Data and its relationships are stored in separate tables.
Examples: Oracle, SQLite.

--------------------------------------------------------------------------------------------------------
NoSQL

NoSQL stores data in the form of document, key-value pairs etc.
NoSQL cannot provide any standard platform to run complex queries.
Supports unstructured data.
NoSQL does not have any pre-defined schema.
Examples: MongoDB, Cassandra.

========================================================================================================
                                        CHAP 7 - NoSQL
========================================================================================================
7.1 Overview

These are used for large sets of distributed data. There are some big data performance issues which are effectively handled by relational databases, such kind of issues are easily managed by NoSQL databases. There are very efficient in analyzing large size unstructured data that may be stored at multiple virtual servers of the cloud.

========================================================================================================
7.2 Architecture

1. Key-value pair:
Every item in the database is stored as an attribute name (key) and linked with value. Key-value pairs are stored in the form of array.

--------------------------------------------------------------------------------------------------------
2. Wide-column stores:
Instead of storing data in rows (relational tuples), the databases are designed for storing the data in the section of columns. Wide-column store provides high scalability and improves the performance of the system.
Examples: Hbase, BigTable, HyperTable.

--------------------------------------------------------------------------------------------------------
3. Document Database:
Document databases work on key-value pair and contain more complex data. Each document is assigned a unique key which helps to retrieve the document.
Examples: MongoDB, CouchDB.

--------------------------------------------------------------------------------------------------------
4. Graph Database:
Graph database is based on graph theory and especially designed for the data elements which are interconnected in the network.
Examples: Neo4j, Polyglot.

========================================================================================================
7.3 Features

Non-relational

    NoSQL databases never follow the relational model
    Never provide tables with flat fixed-column records
    Work with self-contained aggregates or BLOBs
    Doesn't require object-relational mapping and data normalization
    No complex features like query languages, query planners,

    referential integrity joins, ACID 

--------------------------------------------------------------------------------------------------------
Schema-free

    NoSQL databases are either schema-free or have relaxed schemas
    Do not require any sort of definition of the schema of the data
    Offers heterogeneous structures of data in the same domain

--------------------------------------------------------------------------------------------------------
Simple API

    Offers easy to use interfaces for storage and querying data provided
    APIs allow low-level data manipulation & selection methods
    Text-based protocols mostly used with HTTP REST with JSON
    Mostly used no standard based NoSQL query language
    Web-enabled databases running as internet-facing services

--------------------------------------------------------------------------------------------------------
Distributed

    Multiple NoSQL databases can be executed in a distributed fashion
    Offers auto-scaling and fail-over capabilities
    Often ACID concept can be sacrificed for scalability and throughput
    Mostly no synchronous replication between distributed nodes Asynchronous Multi-Master Replication, peer-to-peer, HDFS Replication
    Only providing eventual consistency
    Shared Nothing Architecture. This enables less coordination and higher distribution.

========================================================================================================
7.4 Advantages


    * Can be used as Primary or Analytic Data Source
    * Big Data Capability
    * No Single Point of Failure
    * Easy Replication
    * No Need for Separate Caching Layer
    * It provides fast performance and horizontal scalability.
    * Can handle structured, semi-structured, and unstructured data with equal effect
    * Object-oriented programming which is easy to use and flexible
    * NoSQL databases don't need a dedicated high-performance server
    * Support Key Developer Languages and Platforms
    * Simple to implement than using RDBMS
    * It can serve as the primary data source for online applications.
    * Handles big data which manages data velocity, variety, volume, and complexity
    * Excels at distributed database and multi-data center operations
    * Eliminates the need for a specific caching layer to store data
    * Offers a flexible schema design which can easily be altered without downtime or service disruption


========================================================================================================
7.5 Basics

========================================================================================================
7.6 Servers

========================================================================================================
7.7 Databases

========================================================================================================
7.8 Collections

A collection may store a number of documents. 
A collection is analogous to a table of an RDBMS.
A collection may store documents those who are not same in structure. 
This is possible because MongoDB is a Schema-free database. 
In a relational database like MySQL, a schema defines the organization / structure of data in a database. 
MongoDB does not require such a set of formula defining structure of data. 
So, it is quite possible to store documents of varying structures in a collection. 

========================================================================================================
7.9 Documents / Objects

In contrast to rows and columns, NoSQL databases keep data in documents. These documents follow a minimum of standard format rules (so that the database can understand it for post processing). The format used could be JSON, XML, YAML etc. The JSON format is the format of choice for NoSQL databases, and for good reason. A JSON document is simply more compact and more readable.

JSON (JavaScript Object Notation) is a data representation format formulated by the JavaScript programming language. But because of its textual nature it is also used by all other programming languages.

========================================================================================================
7.8 CRUD

CRUD operations create, read, update, and delete documents.

--------------------------------------------------------------------------------------------------------
Create Operations

Create or insert operations add new documents to a collection. If the collection does not currently exist, insert operations will create the collection.

MongoDB provides the following methods to insert documents into a collection:

    db.collection.insertOne() New in version 3.2
    db.collection.insertMany() New in version 3.2

--------------------------------------------------------------------------------------------------------
Read Operations

Read operations retrieve documents from a collection; i.e. query a collection for documents. MongoDB provides the following methods to read documents from a collection:

    db.collection.find()

You can specify query filters or criteria that identify the documents to return.

--------------------------------------------------------------------------------------------------------
Update Operations

Update operations modify existing documents in a collection. MongoDB provides the following methods to update documents of a collection:

    db.collection.updateOne() New in version 3.2
    db.collection.updateMany() New in version 3.2
    db.collection.replaceOne() New in version 3.2

In MongoDB, update operations target a single collection. All write operations in MongoDB are atomic on the level of a single document.

You can specify criteria, or filters, that identify the documents to update. These filters use the same syntax as read operations.

--------------------------------------------------------------------------------------------------------
Delete Operations

Delete operations remove documents from a collection. MongoDB provides the following methods to delete documents of a collection:

    db.collection.deleteOne() New in version 3.2
    db.collection.deleteMany() New in version 3.2

In MongoDB, delete operations target a single collection. All write operations in MongoDB are atomic on the level of a single document.

You can specify criteria, or filters, that identify the documents to remove. These filters use the same syntax as read operations.

========================================================================================================
7.9 Indexes

Indexes are special data structures that store a small portion of the collection’s data set in an easy to traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field. The ordering of the index entries supports efficient equality matches and range-based query operations. In addition, MongoDB can return sorted results by using the ordering in the index.

========================================================================================================